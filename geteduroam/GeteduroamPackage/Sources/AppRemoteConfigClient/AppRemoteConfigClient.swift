import AppRemoteConfigService
import AppRemoteConfigServiceMacros
import Dependencies
import DependenciesMacros
import Foundation
import Perception

public enum AppState: String, CaseIterable {
    case active, updateRecommended, updateRequired, updateOSRecommended, updateOSRequired, obsolete, disabled
}

public struct IgnoreServerCertificateImportFailureEnabled: Sendable {
    fileprivate init() { }
}

public struct IgnoreMissingServerCertificateNameEnabled: Sendable {
    fileprivate init() { }
}

/// Remotely configurable values
@AppRemoteConfigValues @Perceptible @MainActor
public class Values {
    /// Application state for app life management
    fileprivate(set) var appState: String = AppState.active.rawValue
    public fileprivate(set) var appStateEnum: AppState {
        get {
            AppState(rawValue: appState) ?? .active
        }
        set {
            appState = newValue.rawValue
        }
    }
    
    public var appDisabled: Bool {
        [AppState.updateRequired, .updateOSRequired, .disabled].contains(appStateEnum)
    }
    
    /// Enabled when the API is undergoing maintenance
    public fileprivate(set) var maintenance: Bool = false
    
    /// A feature flag to ignore failed server certificate import
    fileprivate var ignoreServerCertificateImportFailure: Bool = true
    public var ignoreServerCertificateImportFailureEnabled: IgnoreServerCertificateImportFailureEnabled? { ignoreServerCertificateImportFailure ? IgnoreServerCertificateImportFailureEnabled() : nil }
    
    /// A feature flag to ignore missing server certificate name
    fileprivate var ignoreMissingServerCertificateName: Bool = false
    public var ignoreMissingServerCertificateNameEnabled: IgnoreMissingServerCertificateNameEnabled? { ignoreMissingServerCertificateName ? IgnoreMissingServerCertificateNameEnabled() : nil }
}

@Perceptible @MainActor
public class LocalValues {
    public var showHiddenSettings: Bool = false
}

@DependencyClient
public struct AppRemoteConfigClient: Sendable {
    public var values: @Sendable @MainActor () -> Values = { Values() }
    public var localValues: @Sendable @MainActor () -> LocalValues = { LocalValues() }
}

extension DependencyValues {
    public var configClient: AppRemoteConfigClient {
        get { self[AppRemoteConfigClient.self] }
        set { self[AppRemoteConfigClient.self] = newValue }
    }
}

extension AppRemoteConfigClient: TestDependencyKey {
    public static let testValue = Self()
}

extension AppRemoteConfigClient: DependencyKey {
    public static let liveValue = {
        let live = LockIsolated<LiveMainActorAppRemoteConfigClient?>(nil)
        return AppRemoteConfigClient(
            values: {
                if live.value == nil {
                    let dependency = LiveMainActorAppRemoteConfigClient()
                    live.setValue(dependency)
                }
                return live.value!.values
            },
            localValues: {
                if live.value == nil {
                    let dependency = LiveMainActorAppRemoteConfigClient()
                    live.setValue(dependency)
                }
                return live.value!.localValues
            }
        )
    }()
}

// This is used to workaround the error:
// Main actor-isolated static property 'liveValue' cannot be used to satisfy nonisolated protocol requirement.
@MainActor
private class LiveMainActorAppRemoteConfigClient {
    fileprivate let values: Values
    fileprivate let localValues: LocalValues
    private let service: AppRemoteConfigService
    
    init() {
        let url = URL(string: Bundle.main.infoDictionary!["RemoteConfigurationURL"] as! String)!
        let bundledConfigURL = Bundle.main.url(forResource: "appconfig", withExtension: "json")
        values = Values()
        localValues = LocalValues()
        service = AppRemoteConfigService(url: url, bundledConfigURL: bundledConfigURL, bundleIdentifier: Bundle.main.bundleIdentifier!, apply: values.apply(settings:))
    }
}

// Below is work in progress. Eventually this view should be generated by a macro.

import SwiftUI

public struct ValuesEditor: View {
    public init() {
        @Dependency(\.configClient) var configClient
        values = configClient.values()
        localValues = configClient.localValues()
    }
    
    @Perception.Bindable var values: Values
    @Perception.Bindable var localValues: LocalValues
    
    public var body: some View {
        WithPerceptionTracking {
            Form {
                Section {
                    Text("This menu is for testing purposes only.")
                }
                
                Section {
                    Picker(
                        selection: $values.appStateEnum,
                        content: {
                            ForEach(AppState.allCases, id: \.self) { entry in
                                Text(entry.rawValue.camelCaseToWords()).tag(entry as AppState?)
                            }
                        },
                        label: {
                            Text("appState".camelCaseToWords())
                        })
                    Toggle(isOn: $values.maintenance) {
                        Text("maintenance".camelCaseToWords())
                    }
                }
                
                Section(
                    content: {
                        Toggle(isOn: $values.ignoreServerCertificateImportFailure) {
                            Text("ignoreServerCertificateImportFailure".camelCaseToWords())
                        }
                        Toggle(isOn: $values.ignoreMissingServerCertificateName) {
                            Text("ignoreMissingServerCertificateName".camelCaseToWords())
                        }
                    },
                    header: {
                        Text("Connecting")
                    }
                )
            }
        }
    }
}

extension String {
    func camelCaseToWords() -> String {
        replacingOccurrences(of: "([A-Z])",
                             with: " $1",
                             options: .regularExpression,
                             range: range(of: self))
        .trimmingCharacters(in: .whitespacesAndNewlines)
        .capitalized
        .replacingOccurrences(of: "([A-Z]) ([A-Z])",
                             with: "$1$2",
                             options: .regularExpression,
                             range: range(of: self))
    }
}
